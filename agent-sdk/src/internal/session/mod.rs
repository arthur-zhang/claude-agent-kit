//! Agent Session Actor
//!
//! This module implements the main actor loop for the Claude Client.
//! It handles the state and protocol logic in a dedicated task, communicating
//! via channels.

use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{broadcast, mpsc, Mutex};
use tracing::{debug, error, info, warn};

use crate::internal::transport::WriteHalf;
use crate::types::{
    CanUseTool, Error, HookCallback, HookContext, HookInput, PermissionResult,
    ProtocolMessage, Result, SDKControlRequestType, SDKControlResponse, ToolPermissionContext,
};
use tokio::process::ChildStdin;

/// Commands sent from Client to Session Actor
#[derive(Debug)]
pub enum ClientCommand {
    SendUserMessage {
        message: String,
        session_id: String,
    },
    SendInputMessage(crate::types::InputMessage), // New variant
    SetModel(Option<String>),
    SetPermissionMode(String),
    Interrupt(String),  // request_id generated by caller
    RewindFiles(String),
    Disconnect,
    GetInitData(tokio::sync::oneshot::Sender<Option<serde_json::Value>>),
}

/// The Agent Session Actor
pub struct AgentSession {
    // Communication channels
    command_rx: mpsc::Receiver<ClientCommand>,
    protocol_rx: mpsc::Receiver<ProtocolMessage>,
    event_tx: broadcast::Sender<ProtocolMessage>,
    
    // Transport output
    write_half: Arc<Mutex<WriteHalf<ChildStdin>>>,
    
    // State
    request_counter: usize,
    init_data: Option<serde_json::Value>,
    
    // Hooks and Callbacks
    hook_callbacks: HashMap<String, Box<dyn HookCallback>>,
    can_use_tool: Option<Box<dyn CanUseTool>>,
}

impl AgentSession {
    pub fn new(
        command_rx: mpsc::Receiver<ClientCommand>,
        protocol_rx: mpsc::Receiver<ProtocolMessage>,
        write_half: WriteHalf<ChildStdin>,
        can_use_tool: Option<Box<dyn CanUseTool>>,
    ) -> (Self, broadcast::Receiver<ProtocolMessage>) {
        let (event_tx, event_rx) = broadcast::channel(100);
        
        let session = Self {
            command_rx,
            protocol_rx,
            event_tx,
            write_half: Arc::new(Mutex::new(write_half)),
            request_counter: 0,
            init_data: None,
            hook_callbacks: HashMap::new(),
            can_use_tool,
        };
        
        (session, event_rx)
    }

    /// Run the session actor loop
    pub async fn run(mut self) {
        info!("ðŸš€ AgentSession actor started");

        loop {
            tokio::select! {
                // Handle commands from Client
                Some(cmd) = self.command_rx.recv() => {
                    if let ClientCommand::Disconnect = cmd {
                        info!("ðŸ›‘ Disconnect command received");
                        break;
                    }
                    if let Err(e) = self.handle_client_command(cmd).await {
                        error!("Error handling client command: {}", e);
                    }
                }

                // Handle protocol messages from Transport
                Some(msg) = self.protocol_rx.recv() => {
                    if let Err(e) = self.handle_protocol_message(msg).await {
                        error!("Error handling protocol message: {}", e);
                    }
                }

                // All channels closed - exit gracefully
                else => {
                    info!("ðŸ›‘ All channels closed, exiting session loop");
                    break;
                }
            }
        }

        info!("ðŸ›‘ AgentSession actor stopped");
    }

    async fn handle_protocol_message(&mut self, msg: ProtocolMessage) -> Result<()> {
        match msg {
            ProtocolMessage::ControlRequest { request_id, request } => {
                self.handle_control_request(request_id, request).await?;
            }
            ProtocolMessage::System(ref system) if system.subtype == "init" => {
                // Capture init data
                self.init_data = Some(serde_json::Value::Object(system.extra.clone()));
                // Forward to subscribers
                let _ = self.event_tx.send(msg);
            }
            // Forward control responses to subscribers for request-response tracking
            ProtocolMessage::ControlResponse { ref response } => {
                debug!("ðŸ“¨ Received control_response: {:?}", response);
                let _ = self.event_tx.send(msg);
            }
            _ => {
                // Forward other messages to subscribers
                let _ = self.event_tx.send(msg);
            }
        }
        Ok(())
    }

    async fn handle_client_command(&mut self, cmd: ClientCommand) -> Result<()> {
        match cmd {
            ClientCommand::SendUserMessage { message, session_id } => {
                let msg = crate::types::InputMessage::user(&message, session_id);
                self.send_json(&msg).await?;
            }
            ClientCommand::SendInputMessage(msg) => {
                self.send_json(&msg).await?;
            }
            ClientCommand::SetModel(model) => {
                let req = serde_json::json!({
                    "subtype": "set_model",
                    "model": model
                });
                let _ = self.send_control_request(req).await?;
            }
            ClientCommand::SetPermissionMode(mode) => {
                let req = serde_json::json!({
                    "subtype": "set_permission_mode",
                    "mode": mode
                });
                let _ = self.send_control_request(req).await?;
            }
            ClientCommand::Interrupt(request_id) => {
                let req = serde_json::json!({ "subtype": "interrupt" });
                self.send_control_request_with_id(&request_id, req).await?;
            }
            ClientCommand::RewindFiles(id) => {
                let req = serde_json::json!({
                    "subtype": "rewind_files",
                    "user_message_id": id
                });
                let _ = self.send_control_request(req).await?;
            }
            ClientCommand::GetInitData(tx) => {
                let _ = tx.send(self.init_data.clone());
            }
            ClientCommand::Disconnect => {
                // Handled in main loop
            }
        }
        Ok(())
    }

    async fn handle_control_request(&mut self, request_id: String, request: SDKControlRequestType) -> Result<()> {
        info!("ðŸ”§ Processing control_request: {:?}", std::mem::discriminant(&request));

        let response_data = match request {
            SDKControlRequestType::CanUseTool { tool_name, input, .. } => {
                self.handle_permission_request(&tool_name, &input).await?
            }
            SDKControlRequestType::HookCallback { callback_id, input, tool_use_id } => {
                self.handle_hook_callback(&callback_id, &input, tool_use_id).await?
            }
            _ => {
                warn!("Unsupported request type: {:?}", std::mem::discriminant(&request));
                return Ok(()); // Ignore unsupported requests
            }
        };

        let response = SDKControlResponse::success(request_id, response_data);
        self.send_json(&response).await?;
        
        Ok(())
    }

    async fn handle_permission_request(
        &self,
        tool_name: &str,
        input: &serde_json::Value,
    ) -> Result<serde_json::Value> {
        let can_use_tool = self.can_use_tool.as_ref().ok_or_else(|| {
            Error::ControlProtocol("canUseTool callback not provided".to_string())
        })?;

        let context = ToolPermissionContext {
            signal: None,
            suggestions: vec![],
        };

        let result = can_use_tool.can_use(tool_name, input, &context).await
            .map_err(|e| Error::ControlProtocol(e.to_string()))?;

        let response = match result {
            PermissionResult::Allow(allow) => {
                let mut json = serde_json::json!({
                    "behavior": "allow",
                    "updatedInput": allow.updated_input.unwrap_or_else(|| input.clone()),
                });

                if let Some(permissions) = allow.updated_permissions {
                    json["updatedPermissions"] = serde_json::to_value(permissions).unwrap();
                }
                json
            }
            PermissionResult::Deny(deny) => {
                serde_json::json!({
                    "behavior": "deny",
                    "message": deny.message,
                    "interrupt": deny.interrupt
                })
            }
        };

        Ok(response)
    }

    async fn handle_hook_callback(
        &mut self,
        callback_id: &str,
        input: &serde_json::Value,
        tool_use_id: Option<String>,
    ) -> Result<serde_json::Value> {
        let callback = self.hook_callbacks.get(callback_id).ok_or_else(|| {
            Error::ControlProtocol(format!("Hook callback not found: {}", callback_id))
        })?;

        let hook_input: HookInput = serde_json::from_value(input.clone())?;
        let context = HookContext { signal: None };
        let output = callback.call(hook_input, tool_use_id, context).await?;
        
        Ok(serde_json::to_value(&output)?)
    }

    async fn send_control_request(&mut self, request_data: serde_json::Value) -> Result<String> {
        self.request_counter += 1;
        let request_id = format!("req_{}_{}", self.request_counter, uuid::Uuid::new_v4());
        self.send_control_request_with_id(&request_id, request_data).await?;
        Ok(request_id)
    }

    async fn send_control_request_with_id(&mut self, request_id: &str, request_data: serde_json::Value) -> Result<()> {
        let control_request = serde_json::json!({
            "type": "control_request",
            "request_id": request_id,
            "request": request_data
        });
        self.send_json(&control_request).await
    }

    async fn send_json<T: serde::Serialize>(&self, data: &T) -> Result<()> {
        let json_str = serde_json::to_string(data)? + "\n";
        let mut writer = self.write_half.lock().await;
        writer.write(&json_str).await?;
        Ok(())
    }
}
